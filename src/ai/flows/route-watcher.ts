
// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview Un agente de IA para vigilar rutas que notifica a los usuarios cuando los viajes coinciden con sus rutas guardadas.
 *
 * - watchRoute - Una función que maneja el proceso de vigilancia de rutas.
 * - WatchRouteInput - El tipo de entrada para la función watchRoute.
 * - WatchRouteOutput - El tipo de retorno para la función watchRoute.
 */

import {ai} from '@/ai/genkit';
import {z}  from 'genkit';
import { findPublishedMatchingTripsAction, type FindPublishedMatchingTripsInput, type PublishedTripDetails } from '@/app/dashboard/passenger/saved-routes/actions';
import { Resend } from 'resend';
import { APP_NAME } from '@/lib/constants';

const WatchRouteInputSchema = z.object({
  passengerEmail: z.string().email().describe('La dirección de correo electrónico del pasajero.'),
  origin: z.string().describe('La ubicación de origen deseada para la ruta.'),
  destination: z.string().describe('La ubicación de destino deseada para la ruta.'),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).describe('La fecha deseada para la ruta (AAAA-MM-DD). Este campo representa la fecha preferida del pasajero para su ruta guardada y es la fecha exacta que se debe usar para buscar viajes coincidentes.'),
});
export type WatchRouteInput = z.infer<typeof WatchRouteInputSchema>;

// Modificado: el LLM ya no determina notificationSent, sino que provee el contenido del email.
const WatchRouteLLMOutputSchema = z.object({
  routeMatchFound: z.boolean().describe('Si se encontró una ruta coincidente REAL Y PUBLICADA.'),
  message: z.string().describe('Un mensaje que indica el resultado de la vigilancia de la ruta.'),
  emailSubject: z.string().optional().describe('El asunto del correo electrónico a enviar, si se encontró una coincidencia.'),
  emailMessage: z.string().optional().describe('El cuerpo del mensaje del correo electrónico a enviar, si se encontró una coincidencia.'),
});
// El tipo de salida final del flujo `watchRoute` sí incluirá `notificationSent`.
export interface WatchRouteOutput {
    routeMatchFound: boolean;
    notificationSent: boolean;
    message: string;
}


const resendApiKey = process.env.RESEND_API_KEY;
let resend: Resend | null = null;

if (resendApiKey) {
  resend = new Resend(resendApiKey);
  console.log('[route-watcher] Resend client initialized.');
} else {
  console.warn('[route-watcher] RESEND_API_KEY no está configurada. Las notificaciones por email no funcionarán.');
}

// Esta ya no es una "herramienta" de Genkit para el LLM, sino una función auxiliar.
async function sendNotification(
    passengerEmail: string,
    subject: string,
    message: string
): Promise<boolean> {
  console.log('\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!');
  console.log(`[sendNotification FUNCTION] INVOCADA CON: Email=${passengerEmail}, Subject="${subject}", Message (len)=${message.length}`);
  console.log('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n');

  if (!APP_NAME) {
    console.error('[sendNotification FUNCTION] APP_NAME no está definido. Revisa src/lib/constants.ts. No se puede enviar el email.');
    return false;
  }
  console.log(`[sendNotification FUNCTION] APP_NAME: ${APP_NAME}`);

  if (!resend) {
    console.error('[sendNotification FUNCTION] Resend client no está inicializado. No se puede enviar el email.');
    return false;
  }
   console.log('[sendNotification FUNCTION] Resend client está inicializado.');

  if (!passengerEmail || !message || !subject) {
    console.error(`[sendNotification FUNCTION] Faltan campos requeridos. Recibido: passengerEmail=${passengerEmail}, subject=${subject}, message (longitud)=${message?.length}. No se puede enviar el email.`);
    return false;
  }
  console.log(`[sendNotification FUNCTION] Todos los campos requeridos (passengerEmail, message, subject) están presentes.`);

  console.log(`[sendNotification FUNCTION] Intentando enviar email a ${passengerEmail} con asunto: "${subject}"`);
  try {
    const { data, error } = await resend.emails.send({
      from: `${APP_NAME} <onboarding@resend.dev>`,
      to: [passengerEmail],
      subject: subject,
      html: `<p>${message.replace(/\n/g, '<br>')}</p>`,
      text: message,
    });

    if (error) {
      console.error('[sendNotification FUNCTION] Error al enviar email con Resend:', JSON.stringify(error, null, 2));
      return false;
    }
    console.log('[sendNotification FUNCTION] Email enviado exitosamente. ID:', data?.id);
    return true;
  } catch (e: any) {
    console.error('[sendNotification FUNCTION] Excepción al enviar email:', JSON.stringify(e, Object.getOwnPropertyNames(e), 2));
    return false;
  }
}

export async function watchRoute(input: WatchRouteInput): Promise<WatchRouteOutput> {
  return watchRouteFlow(input);
}

const WatchRoutePromptInputSchema = WatchRouteInputSchema.extend({
    matchingTripsJson: z.string().describe('Un string JSON que representa un array de objetos PublishedTripDetails. Cada objeto describe un viaje publicado que coincide con el origen, destino y fecha. Si no se encontraron viajes, será un string JSON de un array vacío "[]".')
});

// El LLM ahora produce emailSubject y emailMessage, y ya no usa herramientas.
const prompt = ai.definePrompt({
  name: 'watchRoutePrompt',
  input: {schema: WatchRoutePromptInputSchema},
  output: {schema: WatchRouteLLMOutputSchema}, // Usar el nuevo schema de salida del LLM
  // tools: [], // Ya no se necesita la herramienta de notificación para el LLM
  prompt: `Eres un vigilante de rutas inteligente para la aplicación ${APP_NAME}. Tu tarea es analizar una lista de viajes (proporcionada como un string JSON en 'matchingTripsJson') que ya han sido buscados y coinciden con el origen, destino y fecha de la ruta guardada de un pasajero.

  Información de la ruta guardada por el pasajero:
  - Correo del Pasajero: {{{passengerEmail}}}
  - Origen Preferido: {{{origin}}}
  - Destino Preferido: {{{destination}}}
  - Fecha Preferida: {{{date}}} (Formato YYYY-MM-DD)

  Viajes Encontrados (string JSON con detalles de viajes publicados):
  {{{matchingTripsJson}}}

  Proceso de Decisión OBLIGATORIO:
  1. Analiza el string JSON en 'matchingTripsJson'.
     a. Si el string representa un array vacío (ej: "[]"), significa que NO se encontraron viajes publicados que coincidan. En este caso:
        i. Establece 'routeMatchFound' en false.
        ii. En el campo 'message' del output, indica claramente que no se encontraron viajes publicados para la ruta (Origen: {{{origin}}}, Destino: {{{destination}}}, Fecha: {{{date}}}). Por ejemplo: "No se encontraron viajes publicados para tu ruta de {{{origin}}} a {{{destination}}} en la fecha {{{date}}}. Seguiremos vigilando."
        iii. Los campos 'emailSubject' y 'emailMessage' deben quedar indefinidos o vacíos.

  2. Si 'matchingTripsJson' representa un array con UNO O MÁS viajes publicados:
     a. Selecciona el PRIMER viaje del array como la coincidencia principal.
     b. Establece 'routeMatchFound' en true.
     c. En el campo 'message' del output, resume la acción (ej: "¡Coincidencia encontrada! Se encontró un viaje de {{{origin}}} a {{{destination}}} para el {{{date}}}. Se procederá a notificar.").
     d. En el campo 'emailSubject' del output, genera un ASUNTO claro y conciso para el correo de notificación. Ejemplo: "¡Buenas noticias! Encontramos un viaje para ti en ${APP_NAME}".
     e. En el campo 'emailMessage' del output, genera un mensaje de notificación claro y amigable para el pasajero. El mensaje DEBE incluir:
        - Nombre de la aplicación: ${APP_NAME}.
        - Origen del viaje encontrado.
        - Destino del viaje encontrado.
        - Fecha y Hora de salida del viaje encontrado (el campo 'departureDateTime' del viaje encontrado YA ESTÁ FORMATEADO como "dd MMM yyyy a las HH:mm").
        - Nombre del conductor (campo 'driverFullName'), si está disponible, o "Conductor Anónimo".
        - Correo electrónico del conductor (campo 'driverEmail'), si está disponible y no es null. Si es null, omitir esta línea.
        - Número de asientos disponibles (campo 'seatsAvailable').
        - Un saludo cordial y una despedida.

  No inventes viajes. Basa tu decisión EXCLUSIVAMENTE en los datos de 'matchingTripsJson'.
  Asegúrate de que la salida sea un objeto JSON válido que cumpla con WatchRouteLLMOutputSchema.
`,
  config: {
    safetySettings: [
      { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_ONLY_HIGH' },
      { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' },
      { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
      { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_LOW_AND_ABOVE' },
    ],
  },
});

const watchRouteFlow = ai.defineFlow(
  {
    name: 'watchRouteFlow',
    inputSchema: WatchRouteInputSchema,
    // El schema de salida del flujo sigue siendo WatchRouteOutput (con notificationSent boolean)
    // Pero el prompt interno produce WatchRouteLLMOutputSchema
  },
  async (input): Promise<WatchRouteOutput> => { // Asegurar que el tipo de retorno del flow sea WatchRouteOutput
    console.log('[watchRouteFlow] Flow iniciado con input:', JSON.stringify(input, null, 2));

    const searchInput: FindPublishedMatchingTripsInput = {
        origin: input.origin,
        destination: input.destination,
        searchDate: input.date,
    };
    console.log('[watchRouteFlow] Llamando a findPublishedMatchingTripsAction con input:', JSON.stringify(searchInput, null, 2));
    let matchingTrips: PublishedTripDetails[] = [];
    try {
        matchingTrips = await findPublishedMatchingTripsAction(searchInput);
        console.log(`[watchRouteFlow] findPublishedMatchingTripsAction devolvió ${matchingTrips.length} viaje(s). Datos (primeros 500 chars):`, JSON.stringify(matchingTrips, null, 2).substring(0, 500));
    } catch (error: any) {
        console.error('[watchRouteFlow] Error al llamar a findPublishedMatchingTripsAction:', error.message ? error.message : JSON.stringify(error));
        matchingTrips = [];
    }
    
    const matchingTripsJson = JSON.stringify(matchingTrips);
    console.log('[watchRouteFlow] String JSON de viajes coincidentes para el LLM:', matchingTripsJson);

    const promptInput = {
        ...input,
        matchingTripsJson: matchingTripsJson,
    };

    console.log('[watchRouteFlow] Input para el prompt del LLM (incluyendo matchingTripsJson):', JSON.stringify(promptInput, null, 2));

    // El LLM ahora produce WatchRouteLLMOutputSchema (sin 'notificationSent')
    const {output: llmOutput} = await prompt(promptInput);

    console.log('[watchRouteFlow] Output del LLM (WatchRouteLLMOutputSchema):', JSON.stringify(llmOutput, null, 2));

    if (!llmOutput) {
      console.error('[watchRouteFlow] No se recibió una respuesta estructurada del LLM.');
      return {
        routeMatchFound: false,
        notificationSent: false, // Falla la notificación porque el LLM no respondió
        message: `Error: No se recibió una respuesta estructurada del LLM para la ruta de ${input.origin} a ${input.destination}.`,
      };
    }

    let notificationWasSent = false;
    if (llmOutput.routeMatchFound && llmOutput.emailSubject && llmOutput.emailMessage) {
      console.log(`[watchRouteFlow] Coincidencia encontrada por LLM. Procediendo a llamar a sendNotification directamente. Subject: "${llmOutput.emailSubject}"`);
      notificationWasSent = await sendNotification(
        input.passengerEmail,
        llmOutput.emailSubject,
        llmOutput.emailMessage
      );
      console.log(`[watchRouteFlow] Resultado de sendNotification: ${notificationWasSent}`);
    } else if (llmOutput.routeMatchFound && (!llmOutput.emailSubject || !llmOutput.emailMessage)) {
        console.warn("[watchRouteFlow] LLM reportó routeMatchFound=true pero no generó emailSubject o emailMessage. No se intentará la notificación.");
    }


    // Construir el WatchRouteOutput final
    const finalOutput: WatchRouteOutput = {
        routeMatchFound: llmOutput.routeMatchFound,
        notificationSent: notificationWasSent,
        message: llmOutput.message, // Usar el mensaje del LLM
    };

    // Log adicional si el LLM encontró match pero la notificación falló (programáticamente)
    if (finalOutput.routeMatchFound && !finalOutput.notificationSent) {
      console.warn("[watchRouteFlow] LLM reportó routeMatchFound=true pero la función sendNotification devolvió false o no fue llamada (por falta de subject/message).");
    }
    
    console.log('[watchRouteFlow] Output final del flujo (WatchRouteOutput):', JSON.stringify(finalOutput, null, 2));
    return finalOutput;
  }
);
    
