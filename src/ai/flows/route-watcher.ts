
// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview Un agente de IA para vigilar rutas que notifica a los usuarios cuando los viajes coinciden con sus rutas guardadas.
 *
 * - watchRoute - Una función que maneja el proceso de vigilancia de rutas.
 * - WatchRouteInput - El tipo de entrada para la función watchRoute.
 * - WatchRouteOutput - El tipo de retorno para la función watchRoute.
 */

import {ai} from '@/ai/genkit';
import {z}  from 'genkit';
import { findPublishedMatchingTripsAction, type FindPublishedMatchingTripsInput, type PublishedTripDetails } from '@/app/dashboard/passenger/saved-routes/actions';
import { format, parseISO } from 'date-fns'; // Para formatear fechas

const WatchRouteInputSchema = z.object({
  passengerEmail: z.string().email().describe('La dirección de correo electrónico del pasajero.'),
  origin: z.string().describe('La ubicación de origen deseada para la ruta.'),
  destination: z.string().describe('La ubicación de destino deseada para la ruta.'),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).describe('La fecha deseada para la ruta (AAAA-MM-DD). Este campo representa la fecha preferida del pasajero para su ruta guardada y es la fecha exacta que se debe usar para buscar viajes coincidentes.'),
  // driverEmail ya no es necesario aquí, la búsqueda se hará internamente.
});
export type WatchRouteInput = z.infer<typeof WatchRouteInputSchema>;

const WatchRouteOutputSchema = z.object({
  routeMatchFound: z.boolean().describe('Si se encontró una ruta coincidente REAL Y PUBLICADA.'),
  notificationSent: z.boolean().describe('Si se envió una notificación al pasajero (solo si routeMatchFound es true).'),
  message: z.string().describe('Un mensaje que indica el resultado de la vigilancia de la ruta.'),
});
export type WatchRouteOutput = z.infer<typeof WatchRouteOutputSchema>;


// Herramienta para enviar notificaciones por correo electrónico (se mantiene)
const sendNotificationTool = ai.defineTool({ 
  name: 'sendNotificationTool',
  description: 'Envía una notificación por correo electrónico al pasajero sobre un viaje REAL Y PUBLICADO que coincide con su ruta guardada.',
  inputSchema: z.object({
    passengerEmail: z.string().email().describe('La dirección de correo electrónico del pasajero.'),
    message: z.string().describe('El mensaje a enviar en la notificación, que debe incluir detalles del viaje encontrado.'),
  }),
  outputSchema: z.boolean().describe('Si la notificación se envió con éxito.'),
},
async (input) => {
  console.log(`[sendNotificationTool] Enviando notificación a ${input.passengerEmail}: ${input.message}`);
  // Implementación real de envío de correo aquí (ej. usando un servicio de email)
  // Por ahora, simulamos éxito.
  return true;
});


export async function watchRoute(input: WatchRouteInput): Promise<WatchRouteOutput> {
  return watchRouteFlow(input);
}

// Nuevo schema para el input del prompt del LLM, que ahora incluye los viajes encontrados.
const WatchRoutePromptInputSchema = WatchRouteInputSchema.extend({
    matchingTripsJson: z.string().describe('Un string JSON que representa un array de objetos PublishedTripDetails. Cada objeto describe un viaje publicado que coincide con el origen, destino y fecha. Si no se encontraron viajes, será un string JSON de un array vacío "[]".')
});

const prompt = ai.definePrompt({
  name: 'watchRoutePrompt',
  input: {schema: WatchRoutePromptInputSchema}, // Usamos el nuevo schema
  output: {schema: WatchRouteOutputSchema},
  tools: [sendNotificationTool], // Solo la herramienta de notificación ahora
  prompt: `Eres un vigilante de rutas inteligente. Tu tarea es analizar una lista de viajes (proporcionada como un string JSON en 'matchingTripsJson') que ya han sido buscados y coinciden con el origen, destino y fecha de la ruta guardada de un pasajero.

  Información de la ruta guardada por el pasajero:
  - Correo del Pasajero: {{{passengerEmail}}}
  - Origen Preferido: {{{origin}}}
  - Destino Preferido: {{{destination}}}
  - Fecha Preferida: {{{date}}} (Formato YYYY-MM-DD)

  Viajes Encontrados (string JSON):
  {{{matchingTripsJson}}}

  Proceso de Decisión OBLIGATORIO:
  1. Analiza el string JSON en 'matchingTripsJson'. Si representa un array vacío (ej: "[]"), significa que no se encontraron viajes.
     a. Si no se encontraron viajes:
        i. Establece 'routeMatchFound' en false.
        ii. Establece 'notificationSent' en false.
        iii. En el campo 'message' del output, indica claramente que no se encontraron viajes publicados para la ruta (Origen: {{{origin}}}, Destino: {{{destination}}}, Fecha: {{{date}}}). Por ejemplo: "No se encontraron viajes publicados para tu ruta de {{{origin}}} a {{{destination}}} en la fecha {{{date}}}. Seguiremos vigilando."

  2. Si 'matchingTripsJson' representa un array con uno o más viajes:
     a. Selecciona el primer viaje del array como la coincidencia principal.
     b. Construye un mensaje de notificación claro para el pasajero. El mensaje DEBE incluir:
        - Origen del viaje encontrado.
        - Destino del viaje encontrado.
        - Fecha y Hora de salida del viaje encontrado (formatea el campo 'departureDateTime' del viaje, que es una cadena ISO, a un formato legible como "dd MMM yyyy a las HH:mm").
        - Nombre del conductor (campo 'driverFullName') si está disponible, o "Conductor Anónimo".
        - Correo electrónico del conductor (campo 'driverEmail') si está disponible.
        - Número de asientos disponibles (campo 'seatsAvailable').
     c. Usa la herramienta 'sendNotificationTool' para enviar este mensaje al 'passengerEmail' ({{{passengerEmail}}}) del input.
     d. Establece 'routeMatchFound' en true.
     e. Establece 'notificationSent' según el resultado de la herramienta 'sendNotificationTool'.
     f. En el campo 'message' del output, resume la acción (ej: "Se encontró una coincidencia para tu ruta de {{{origin}}} a {{{destination}}} en la fecha {{{date}}} y se te ha notificado. Detalles del viaje: ...").

  No inventes viajes. Basa tu decisión EXCLUSIVAMENTE en los datos de 'matchingTripsJson'.
  Asegúrate de que la salida sea un objeto JSON válido que cumpla con WatchRouteOutputSchema.
`,
  config: {
    safetySettings: [
      { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_ONLY_HIGH' },
      { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' },
      { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
      { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_LOW_AND_ABOVE' },
    ],
  },
});

const watchRouteFlow = ai.defineFlow(
  {
    name: 'watchRouteFlow',
    inputSchema: WatchRouteInputSchema,
    outputSchema: WatchRouteOutputSchema,
  },
  async (input) => {
    console.log('[watchRouteFlow] Flow iniciado con input:', JSON.stringify(input, null, 2));

    // Paso 1: Buscar viajes coincidentes programáticamente
    const searchInput: FindPublishedMatchingTripsInput = {
        origin: input.origin,
        destination: input.destination,
        searchDate: input.date, // input.date ya está en formato YYYY-MM-DD
    };
    console.log('[watchRouteFlow] Llamando a findPublishedMatchingTripsAction con input:', JSON.stringify(searchInput, null, 2));
    let matchingTrips: PublishedTripDetails[] = [];
    try {
        matchingTrips = await findPublishedMatchingTripsAction(searchInput);
        console.log(`[watchRouteFlow] findPublishedMatchingTripsAction devolvió ${matchingTrips.length} viaje(s). Datos (primeros 500 chars):`, JSON.stringify(matchingTrips, null, 2).substring(0, 500));
    } catch (error: any) {
        console.error('[watchRouteFlow] Error al llamar a findPublishedMatchingTripsAction:', error.message ? error.message : JSON.stringify(error));
        // Continuar con un array vacío de viajes para que el LLM pueda informar que no se encontraron.
    }
    
    const matchingTripsJson = JSON.stringify(matchingTrips);
    console.log('[watchRouteFlow] String JSON de viajes coincidentes para el LLM:', matchingTripsJson);

    // Paso 2: Llamar al LLM con los viajes encontrados (o un array vacío)
    const promptInput = {
        ...input,
        matchingTripsJson: matchingTripsJson,
    };

    console.log('[watchRouteFlow] Input para el prompt del LLM (incluyendo matchingTripsJson):', JSON.stringify(promptInput, null, 2));
    const {output} = await prompt(promptInput); // Llama al prompt del LLM

    console.log('[watchRouteFlow] Output del prompt (LLM):', JSON.stringify(output, null, 2));

    if (output) {
      if (output.routeMatchFound && !output.notificationSent) {
        console.warn("[watchRouteFlow] LLM reportó routeMatchFound=true pero notificationSent=false. Esto podría indicar un problema en la herramienta de notificación o en la lógica del LLM para usarla.");
      }
      return output;
    } else {
      console.error('[watchRouteFlow] No se recibió una respuesta estructurada del LLM.');
      return {
        routeMatchFound: false,
        notificationSent: false,
        message: `Error: No se recibió una respuesta estructurada del LLM para la ruta de ${input.origin} a ${input.destination}.`,
      };
    }
  }
);

// La herramienta findMatchingTripsTool ya no se define aquí ni se exporta,
// ya que la lógica de búsqueda ahora está directamente en el flujo.
// Mantener la exportación de tipos si son necesarios en otros lugares (aunque aquí no lo son)
// export { FindPublishedMatchingTripsInput, PublishedTripDetails }; // Ya se exportan desde saved-routes/actions.ts
