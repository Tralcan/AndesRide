
// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview Un agente de IA para vigilar rutas que notifica a los usuarios cuando los viajes coinciden con sus rutas guardadas.
 *
 * - watchRoute - Una función que maneja el proceso de vigilancia de rutas.
 * - WatchRouteInput - El tipo de entrada para la función watchRoute.
 * - WatchRouteOutput - El tipo de retorno para la función watchRoute.
 */

import {ai} from '@/ai/genkit';
import {z}  from 'genkit';
import { findPublishedMatchingTripsAction, type FindPublishedMatchingTripsInput, type PublishedTripDetails } from '@/app/dashboard/passenger/saved-routes/actions';
import { format, parseISO } from 'date-fns'; // Para formatear fechas

const WatchRouteInputSchema = z.object({
  passengerEmail: z.string().email().describe('La dirección de correo electrónico del pasajero.'),
  origin: z.string().describe('La ubicación de origen deseada para la ruta.'),
  destination: z.string().describe('La ubicación de destino deseada para la ruta.'),
  date: z.string().describe('La fecha deseada para la ruta (AAAA-MM-DD). Este campo representa la fecha preferida del pasajero para su ruta guardada. Si el LLM necesita considerar una fecha específica para una coincidencia, debe usar esta. Si la intención es monitorear para cualquier fecha futura, este campo podría ser una fecha actual o una representación de "cualquier fecha futura".'),
  driverEmail: z.string().email().optional().describe('La dirección de correo electrónico del conductor que ofrece el viaje, si un viaje específico ya ha sido identificado externamente y se pasa a este flujo. En la mayoría de los casos de "vigilancia de ruta", este campo estará vacío, y el LLM NO debe asumir que hay un conductor específico a menos que se proporcione explícitamente.'),
});
export type WatchRouteInput = z.infer<typeof WatchRouteInputSchema>;

const WatchRouteOutputSchema = z.object({
  routeMatchFound: z.boolean().describe('Si se encontró una ruta coincidente REAL Y PUBLICADA.'),
  notificationSent: z.boolean().describe('Si se envió una notificación al pasajero (solo si routeMatchFound es true).'),
  message: z.string().describe('Un mensaje que indica el resultado de la vigilancia de la ruta.'),
});
export type WatchRouteOutput = z.infer<typeof WatchRouteOutputSchema>;


// Herramienta para buscar viajes publicados que coincidan
const FindMatchingTripsInputToolSchema = z.object({
  origin: z.string().describe("La ubicación de origen para buscar viajes."),
  destination: z.string().describe("La ubicación de destino para buscar viajes."),
  searchDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).describe("La fecha para buscar viajes (formato YYYY-MM-DD)."),
});

const FindMatchingTripsOutputToolSchema = z.array(z.object({
  tripId: z.string(),
  driverEmail: z.string().email().nullable(),
  driverFullName: z.string().nullable(),
  departureDateTime: z.string().datetime(), // ISO string
  origin: z.string(),
  destination: z.string(),
  seatsAvailable: z.number().int().min(0),
}));

const findMatchingTripsTool = ai.defineTool(
  {
    name: 'findMatchingTripsTool',
    description: 'Busca viajes publicados REALES en la base de datos que coincidan con un origen, destino y fecha específicos.',
    inputSchema: FindMatchingTripsInputToolSchema,
    outputSchema: FindMatchingTripsOutputToolSchema,
  },
  async (input: FindPublishedMatchingTripsInput): Promise<PublishedTripDetails[]> => {
    console.log('[findMatchingTripsTool] Tool called with input:', JSON.stringify(input, null, 2)); // Loguear el input exacto que recibe la herramienta
    try {
      const matchingTrips = await findPublishedMatchingTripsAction({
        origin: input.origin,
        destination: input.destination,
        searchDate: input.searchDate,
      });
      console.log(`[findMatchingTripsTool] Trips found by findPublishedMatchingTripsAction: ${matchingTrips.length} trips. Data:`, JSON.stringify(matchingTrips, null, 2));
      return matchingTrips;
    } catch (error) {
      console.error('[findMatchingTripsTool] Error calling findPublishedMatchingTripsAction:', error);
      return []; // Devuelve un array vacío en caso de error para que el LLM sepa que no hay coincidencias.
    }
  }
);

// Herramienta para enviar notificaciones por correo electrónico
const sendNotification = ai.defineTool({
  name: 'sendNotification',
  description: 'Envía una notificación por correo electrónico al pasajero sobre un viaje REAL Y PUBLICADO que coincide con su ruta guardada.',
  inputSchema: z.object({
    passengerEmail: z.string().email().describe('La dirección de correo electrónico del pasajero.'),
    message: z.string().describe('El mensaje a enviar en la notificación, que debe incluir detalles del viaje encontrado.'),
  }),
  outputSchema: z.boolean().describe('Si la notificación se envió con éxito.'),
},
async (input) => {
  console.log(`[sendNotification Tool] Enviando notificación a ${input.passengerEmail}: ${input.message}`);
  // Implementación real de envío de correo aquí (ej. usando un servicio de email)
  // Por ahora, simulamos éxito.
  return true;
});


export async function watchRoute(input: WatchRouteInput): Promise<WatchRouteOutput> {
  return watchRouteFlow(input);
}

const prompt = ai.definePrompt({
  name: 'watchRoutePrompt',
  input: {schema: WatchRouteInputSchema},
  output: {schema: WatchRouteOutputSchema},
  tools: [findMatchingTripsTool, sendNotification], // Añadida la nueva herramienta
  prompt: `Eres un vigilante de rutas inteligente. Tu tarea principal es ayudar a los pasajeros a encontrar viajes que coincidan con sus rutas guardadas.

  Información de la ruta guardada por el pasajero:
  - Correo del Pasajero: {{{passengerEmail}}}
  - Origen Preferido: {{{origin}}}
  - Destino Preferido: {{{destination}}}
  - Fecha Preferida: {{{date}}} (Formato YYYY-MM-DD. Esta es la fecha que el pasajero guardó.)

  Proceso de Decisión:
  1. Usa la herramienta 'findMatchingTripsTool' para buscar viajes *publicados y disponibles* que coincidan con el origen, destino y fecha preferidos por el pasajero. DEBES usar esta herramienta para verificar la existencia de viajes. El parámetro 'searchDate' para la herramienta DEBE ser la 'Fecha Preferida' del pasajero ({{{date}}}).
  2. Si la herramienta 'findMatchingTripsTool' devuelve uno o más viajes coincidentes:
     a. Selecciona el primer viaje de la lista como la coincidencia.
     b. Construye un mensaje de notificación claro para el pasajero. El mensaje DEBE incluir:
        - Origen del viaje encontrado.
        - Destino del viaje encontrado.
        - Fecha y Hora de salida del viaje encontrado (formatea departureDateTime a un formato legible como "dd MMM yyyy a las HH:mm").
        - Nombre del conductor (driverFullName) si está disponible, o "Conductor Anónimo".
        - Correo electrónico del conductor (driverEmail) si está disponible.
        - Número de asientos disponibles.
     c. Usa la herramienta 'sendNotification' para enviar este mensaje al 'passengerEmail' del input.
     d. Establece 'routeMatchFound' en true.
     e. Establece 'notificationSent' según el resultado de la herramienta 'sendNotification'.
     f. En el campo 'message' del output, resume la acción (ej: "Se encontró una coincidencia para tu ruta de {{{origin}}} a {{{destination}}} y se te ha notificado. Detalles del viaje: ...").
  3. Si la herramienta 'findMatchingTripsTool' NO devuelve ningún viaje coincidente:
     a. Establece 'routeMatchFound' en false.
     b. Establece 'notificationSent' en false.
     c. En el campo 'message' del output, indica claramente que no se encontraron viajes publicados coincidentes para la ruta (Origen: {{{origin}}}, Destino: {{{destination}}}, Fecha: {{{date}}}) y que se seguirá monitoreando. Por ejemplo: "No se encontraron viajes publicados para tu ruta de {{{origin}}} a {{{destination}}} en la fecha {{{date}}}. Seguiremos vigilando."

  No inventes viajes. Basa tu decisión EXCLUSIVAMENTE en los resultados de 'findMatchingTripsTool'.
  Si el campo 'driverEmail' del input está vacío, ignóralo; la información del conductor vendrá de la herramienta 'findMatchingTripsTool'.
  Asegúrate de que la salida sea un objeto JSON válido que cumpla con WatchRouteOutputSchema.
`,
  config: {
    safetySettings: [
      { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_ONLY_HIGH' },
      { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' },
      { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
      { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_LOW_AND_ABOVE' },
    ],
  },
});

const watchRouteFlow = ai.defineFlow(
  {
    name: 'watchRouteFlow',
    inputSchema: WatchRouteInputSchema,
    outputSchema: WatchRouteOutputSchema,
  },
  async (input) => {
    console.log('[watchRouteFlow] Flow iniciado con input:', JSON.stringify(input, null, 2));
    const {output} = await prompt(input); // El LLM ahora usará las herramientas.

    console.log('[watchRouteFlow] Output del prompt (LLM):', JSON.stringify(output, null, 2));

    if (output) {
      // Lógica adicional si es necesaria después de la respuesta del LLM
      if (output.routeMatchFound && !output.notificationSent) {
        console.warn("[watchRouteFlow] LLM reportó routeMatchFound=true pero notificationSent=false. Esto podría indicar un problema en la herramienta de notificación o en la lógica del LLM para usarla.");
        // output.message = `Se detectó una coincidencia para ${input.origin} a ${input.destination}, pero no se pudo enviar la notificación. Por favor, revisa el sistema.`;
      }
      return output;
    } else {
      console.error('[watchRouteFlow] No se recibió una respuesta estructurada del LLM.');
      return {
        routeMatchFound: false,
        notificationSent: false,
        message: `Error: No se recibió una respuesta estructurada del LLM para la ruta de ${input.origin} a ${input.destination}.`,
      };
    }
  }
);
