
// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview Un agente de IA para vigilar rutas que notifica a los usuarios cuando los viajes coinciden con sus rutas guardadas.
 *
 * - watchRoute - Una función que maneja el proceso de vigilancia de rutas.
 * - WatchRouteInput - El tipo de entrada para la función watchRoute.
 * - WatchRouteOutput - El tipo de retorno para la función watchRoute.
 */

import {ai} from '@/ai/genkit';
import {z}  from 'genkit';
import { findPublishedMatchingTripsAction, type FindPublishedMatchingTripsInput, type PublishedTripDetails } from '@/app/dashboard/passenger/saved-routes/actions';
import { format, parseISO } from 'date-fns'; // Para formatear fechas

const WatchRouteInputSchema = z.object({
  passengerEmail: z.string().email().describe('La dirección de correo electrónico del pasajero.'),
  origin: z.string().describe('La ubicación de origen deseada para la ruta.'),
  destination: z.string().describe('La ubicación de destino deseada para la ruta.'),
  date: z.string().describe('La fecha deseada para la ruta (AAAA-MM-DD). Este campo representa la fecha preferida del pasajero para su ruta guardada. Si el LLM necesita considerar una fecha específica para una coincidencia, debe usar esta. Si la intención es monitorear para cualquier fecha futura, este campo podría ser una fecha actual o una representación de "cualquier fecha futura".'),
  driverEmail: z.string().email().optional().describe('La dirección de correo electrónico del conductor que ofrece el viaje, si un viaje específico ya ha sido identificado externamente y se pasa a este flujo. En la mayoría de los casos de "vigilancia de ruta", este campo estará vacío, y el LLM NO debe asumir que hay un conductor específico a menos que se proporcione explícitamente.'),
});
export type WatchRouteInput = z.infer<typeof WatchRouteInputSchema>;

const WatchRouteOutputSchema = z.object({
  routeMatchFound: z.boolean().describe('Si se encontró una ruta coincidente REAL Y PUBLICADA.'),
  notificationSent: z.boolean().describe('Si se envió una notificación al pasajero (solo si routeMatchFound es true).'),
  message: z.string().describe('Un mensaje que indica el resultado de la vigilancia de la ruta.'),
});
export type WatchRouteOutput = z.infer<typeof WatchRouteOutputSchema>;


// Herramienta para buscar viajes publicados que coincidan
const FindMatchingTripsInputToolSchema = z.object({
  origin: z.string().describe("La ubicación de origen para buscar viajes."),
  destination: z.string().describe("La ubicación de destino para buscar viajes."),
  searchDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).describe("La fecha para buscar viajes (formato YYYY-MM-DD). Este DEBE ser el valor del campo 'date' del input principal del flujo."),
});

const FindMatchingTripsOutputToolSchema = z.array(z.object({
  tripId: z.string(),
  driverEmail: z.string().email().nullable(),
  driverFullName: z.string().nullable(),
  departureDateTime: z.string().datetime(), // ISO string
  origin: z.string(),
  destination: z.string(),
  seatsAvailable: z.number().int().min(0),
}));

const findMatchingTripsTool = ai.defineTool(
  {
    name: 'findMatchingTripsTool',
    description: 'Busca viajes publicados REALES en la base de datos que coincidan con un origen, destino y fecha específicos. Usa el valor del campo "date" del input del flujo como "searchDate" para esta herramienta.',
    inputSchema: FindMatchingTripsInputToolSchema,
    outputSchema: FindMatchingTripsOutputToolSchema,
  },
  async (toolInput: FindPublishedMatchingTripsInput): Promise<PublishedTripDetails[]> => {
    console.log('[findMatchingTripsTool] Tool called with input (from LLM):', JSON.stringify(toolInput, null, 2));
    try {
      console.log('[findMatchingTripsTool] Input to findPublishedMatchingTripsAction (from tool):', JSON.stringify(toolInput, null, 2));
      const matchingTrips = await findPublishedMatchingTripsAction(toolInput);
      console.log(`[findMatchingTripsTool] Output from findPublishedMatchingTripsAction (in tool): ${matchingTrips.length} trips. Data (first 500 chars):`, JSON.stringify(matchingTrips, null, 2).substring(0,500));
      return matchingTrips;
    } catch (error: any) {
      console.error('[findMatchingTripsTool] Error calling findPublishedMatchingTripsAction:', error.message ? error.message : error);
      return []; // Devuelve un array vacío en caso de error para que el LLM sepa que no hay coincidencias.
    }
  }
);

// Herramienta para enviar notificaciones por correo electrónico
const sendNotificationTool = ai.defineTool({ // Renombrado para claridad
  name: 'sendNotificationTool',
  description: 'Envía una notificación por correo electrónico al pasajero sobre un viaje REAL Y PUBLICADO que coincide con su ruta guardada.',
  inputSchema: z.object({
    passengerEmail: z.string().email().describe('La dirección de correo electrónico del pasajero.'),
    message: z.string().describe('El mensaje a enviar en la notificación, que debe incluir detalles del viaje encontrado.'),
  }),
  outputSchema: z.boolean().describe('Si la notificación se envió con éxito.'),
},
async (input) => {
  console.log(`[sendNotificationTool] Enviando notificación a ${input.passengerEmail}: ${input.message}`);
  // Implementación real de envío de correo aquí (ej. usando un servicio de email)
  // Por ahora, simulamos éxito.
  return true;
});


export async function watchRoute(input: WatchRouteInput): Promise<WatchRouteOutput> {
  return watchRouteFlow(input);
}

const prompt = ai.definePrompt({
  name: 'watchRoutePrompt',
  input: {schema: WatchRouteInputSchema},
  output: {schema: WatchRouteOutputSchema},
  tools: [findMatchingTripsTool, sendNotificationTool], 
  prompt: `Eres un vigilante de rutas inteligente. Tu tarea principal es ayudar a los pasajeros a encontrar viajes que coincidan con sus rutas guardadas.

  Información de la ruta guardada por el pasajero:
  - Correo del Pasajero: {{{passengerEmail}}}
  - Origen Preferido: {{{origin}}}
  - Destino Preferido: {{{destination}}}
  - Fecha Preferida: {{{date}}} (Formato YYYY-MM-DD. Esta es la fecha que el pasajero guardó y la que debes usar para la búsqueda.)

  Proceso de Decisión OBLIGATORIO:
  1. Tu PRIMERA ACCIÓN debe ser invocar la herramienta 'findMatchingTripsTool'. ES ESENCIAL que uses esta herramienta para buscar viajes *publicados y disponibles* que coincidan EXACTAMENTE con el origen, destino y fecha preferidos por el pasajero.
     - Para el parámetro 'origin' de la herramienta, DEBES usar el valor '{{{origin}}}'.
     - Para el parámetro 'destination' de la herramienta, DEBES usar el valor '{{{destination}}}'.
     - Para el parámetro 'searchDate' de la herramienta 'findMatchingTripsTool', DEBES usar el valor exacto de 'Fecha Preferida' ({{{date}}}) del input. NO uses ninguna otra fecha.

  2. Una vez que tengas el resultado de 'findMatchingTripsTool':
     a. Si la herramienta 'findMatchingTripsTool' devuelve uno o más viajes coincidentes (es decir, el array de resultados no está vacío):
        i. Selecciona el primer viaje de la lista como la coincidencia.
        ii. Construye un mensaje de notificación claro para el pasajero. El mensaje DEBE incluir:
           - Origen del viaje encontrado.
           - Destino del viaje encontrado.
           - Fecha y Hora de salida del viaje encontrado (formatea departureDateTime a un formato legible como "dd MMM yyyy a las HH:mm").
           - Nombre del conductor (driverFullName) si está disponible, o "Conductor Anónimo".
           - Correo electrónico del conductor (driverEmail) si está disponible.
           - Número de asientos disponibles.
        iii. Usa la herramienta 'sendNotificationTool' para enviar este mensaje al 'passengerEmail' ({{{passengerEmail}}}) del input.
        iv. Establece 'routeMatchFound' en true.
        v. Establece 'notificationSent' según el resultado de la herramienta 'sendNotificationTool'.
        vi. En el campo 'message' del output, resume la acción (ej: "Se encontró una coincidencia para tu ruta de {{{origin}}} a {{{destination}}} en la fecha {{{date}}} y se te ha notificado. Detalles del viaje: ...").

     b. Si la herramienta 'findMatchingTripsTool' NO devuelve ningún viaje coincidente (es decir, el array de resultados está vacío):
        i. Establece 'routeMatchFound' en false.
        ii. Establece 'notificationSent' en false.
        iii. En el campo 'message' del output, indica claramente que no se encontraron viajes publicados coincidentes para la ruta (Origen: {{{origin}}}, Destino: {{{destination}}}, Fecha: {{{date}}}) y que se seguirá monitoreando. Por ejemplo: "No se encontraron viajes publicados para tu ruta de {{{origin}}} a {{{destination}}} en la fecha {{{date}}}. Seguiremos vigilando."

  No inventes viajes. Basa tu decisión EXCLUSIVAMENTE en los resultados de 'findMatchingTripsTool'.
  Asegúrate de que la salida sea un objeto JSON válido que cumpla con WatchRouteOutputSchema.
`,
  config: {
    safetySettings: [
      { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_ONLY_HIGH' },
      { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' },
      { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
      { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_LOW_AND_ABOVE' },
    ],
  },
});

const watchRouteFlow = ai.defineFlow(
  {
    name: 'watchRouteFlow',
    inputSchema: WatchRouteInputSchema,
    outputSchema: WatchRouteOutputSchema,
  },
  async (input) => {
    console.log('[watchRouteFlow] Flow iniciado con input:', JSON.stringify(input, null, 2));
    const {output} = await prompt(input);

    console.log('[watchRouteFlow] Output del prompt (LLM):', JSON.stringify(output, null, 2));

    if (output) {
      if (output.routeMatchFound && !output.notificationSent) {
        console.warn("[watchRouteFlow] LLM reportó routeMatchFound=true pero notificationSent=false. Esto podría indicar un problema en la herramienta de notificación o en la lógica del LLM para usarla.");
      }
      return output;
    } else {
      console.error('[watchRouteFlow] No se recibió una respuesta estructurada del LLM.');
      return {
        routeMatchFound: false,
        notificationSent: false,
        message: `Error: No se recibió una respuesta estructurada del LLM para la ruta de ${input.origin} a ${input.destination}.`,
      };
    }
  }
);

