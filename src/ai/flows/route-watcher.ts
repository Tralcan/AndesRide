
// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview Un agente de IA para vigilar rutas que notifica a los usuarios cuando los viajes coinciden con sus rutas guardadas.
 *
 * - watchRoute - Una función que maneja el proceso de vigilancia de rutas.
 * - WatchRouteInput - El tipo de entrada para la función watchRoute.
 * - WatchRouteOutput - El tipo de retorno para la función watchRoute.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const WatchRouteInputSchema = z.object({
  passengerEmail: z.string().email().describe('La dirección de correo electrónico del pasajero.'),
  origin: z.string().describe('La ubicación de origen deseada para la ruta.'),
  destination: z.string().describe('La ubicación de destino deseada para la ruta.'),
  date: z.string().describe('La fecha deseada para la ruta (AAAA-MM-DD).'),
  driverEmail: z.string().email().optional().describe('La dirección de correo electrónico del conductor que ofrece el viaje, si está disponible.'),
});
export type WatchRouteInput = z.infer<typeof WatchRouteInputSchema>;

const WatchRouteOutputSchema = z.object({
  routeMatchFound: z.boolean().describe('Si se encontró una ruta coincidente.'),
  notificationSent: z.boolean().describe('Si se envió una notificación al pasajero.'),
  message: z.string().describe('Un mensaje que indica el resultado de la vigilancia de la ruta.'),
});
export type WatchRouteOutput = z.infer<typeof WatchRouteOutputSchema>;


// Define a tool to send email notifications (implementation not provided)
const sendNotification = ai.defineTool({
  name: 'sendNotification',
  description: 'Envía una notificación por correo electrónico al pasajero sobre un viaje coincidente.',
  inputSchema: z.object({
    passengerEmail: z.string().email().describe('La dirección de correo electrónico del pasajero.'),
    message: z.string().describe('El mensaje a enviar en la notificación.'),
  }),
  outputSchema: z.boolean().describe('Si la notificación se envió con éxito.'),
},
async (input) => {
  // Placeholder implementation for sending a notification.
  // In a real application, this would use an email service or similar.
  console.log(`Enviando notificación a ${input.passengerEmail}: ${input.message}`);
  return true; // Assume success for this example
});


export async function watchRoute(input: WatchRouteInput): Promise<WatchRouteOutput> {
  return watchRouteFlow(input);
}

const prompt = ai.definePrompt({
  name: 'watchRoutePrompt',
  input: {schema: WatchRouteInputSchema},
  output: {schema: WatchRouteOutputSchema},
  tools: [sendNotification],
  prompt: `Eres un vigilante de rutas que identifica cuándo un viaje coincide con la ruta preferida de un pasajero y envía una notificación.

  Correo del Pasajero: {{{passengerEmail}}}
  Origen: {{{origin}}}
  Destino: {{{destination}}}
  Fecha: {{{date}}}

  Correo del Conductor (si está disponible): {{{driverEmail}}}

  Determina si un viaje coincide con la ruta preferida del pasajero. Si coincide, usa la herramienta sendNotification para notificar al pasajero.
  El mensaje de notificación debe incluir el correo electrónico del conductor (si está disponible), origen, destino y fecha.
  Establece routeMatchFound en true si se encuentra una coincidencia, de lo contrario, en false.
  Establece notificationSent en true si se envía una notificación, de lo contrario, en false.
  Incluye un mensaje útil en el campo message para resumir los resultados.

  Si no hay correo electrónico del conductor disponible, menciona que la notificación incluye información sobre el origen, destino y fecha.

  Asegúrate de que la salida sea un objeto JSON válido.
`,
  config: {
    safetySettings: [
      {
        category: 'HARM_CATEGORY_HATE_SPEECH',
        threshold: 'BLOCK_ONLY_HIGH',
      },
      {
        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
        threshold: 'BLOCK_NONE',
      },
      {
        category: 'HARM_CATEGORY_HARASSMENT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
        threshold: 'BLOCK_LOW_AND_ABOVE',
      },
    ],
  },
});

const watchRouteFlow = ai.defineFlow(
  {
    name: 'watchRouteFlow',
    inputSchema: WatchRouteInputSchema,
    outputSchema: WatchRouteOutputSchema,
  },
  async input => {
    const {output} = await prompt(input);

    if (output) {
      return output;
    } else {
      return {
        routeMatchFound: false,
        notificationSent: false,
        message: 'No se recibió salida del prompt.',
      };
    }
  }
);
