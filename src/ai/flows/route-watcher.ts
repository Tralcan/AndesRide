
// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview Un agente de IA para vigilar rutas que notifica a los usuarios cuando los viajes coinciden con sus rutas guardadas.
 *
 * - watchRoute - Una función que maneja el proceso de vigilancia de rutas.
 * - WatchRouteInput - El tipo de entrada para la función watchRoute.
 * - WatchRouteOutput - El tipo de retorno para la función watchRoute.
 */

import {ai} from '@/ai/genkit';
import {z}  from 'genkit';
import { findPublishedMatchingTripsAction, type FindPublishedMatchingTripsInput, type PublishedTripDetails } from '@/app/dashboard/passenger/saved-routes/actions';
import { Resend } from 'resend';
import { APP_NAME } from '@/lib/constants';

const WatchRouteInputSchema = z.object({
  passengerEmail: z.string().email().describe('La dirección de correo electrónico del pasajero.'),
  origin: z.string().describe('La ubicación de origen deseada para la ruta.'),
  destination: z.string().describe('La ubicación de destino deseada para la ruta.'),
  date: z.string().regex(/^\d{4}-\d{2}-\d{2}$/).describe('La fecha deseada para la ruta (AAAA-MM-DD). Este campo representa la fecha preferida del pasajero para su ruta guardada y es la fecha exacta que se debe usar para buscar viajes coincidentes.'),
});
export type WatchRouteInput = z.infer<typeof WatchRouteInputSchema>;

const WatchRouteOutputSchema = z.object({
  routeMatchFound: z.boolean().describe('Si se encontró una ruta coincidente REAL Y PUBLICADA.'),
  notificationSent: z.boolean().describe('Si se envió una notificación al pasajero (solo si routeMatchFound es true).'),
  message: z.string().describe('Un mensaje que indica el resultado de la vigilancia de la ruta.'),
});
export type WatchRouteOutput = z.infer<typeof WatchRouteOutputSchema>;


const resendApiKey = process.env.RESEND_API_KEY;
let resend: Resend | null = null;

if (resendApiKey) {
  resend = new Resend(resendApiKey);
  console.log('[route-watcher] Resend client initialized.');
} else {
  console.warn('[route-watcher] RESEND_API_KEY no está configurada. Las notificaciones por email no funcionarán.');
}

const sendNotificationTool = ai.defineTool({
  name: 'sendNotificationTool',
  description: 'Envía una notificación por correo electrónico al pasajero sobre un viaje REAL Y PUBLICADO que coincide con su ruta guardada.',
  inputSchema: z.object({
    passengerEmail: z.string().email().describe('La dirección de correo electrónico del pasajero.'),
    message: z.string().describe('El mensaje a enviar en la notificación, que debe incluir detalles del viaje encontrado.'),
    subject: z.string().describe('El asunto del correo electrónico.'),
  }),
  outputSchema: z.boolean().describe('Si la notificación se envió con éxito.'),
},
async (input) => {
  if (!resend) {
    console.error('[sendNotificationTool] Resend client no está inicializado. No se puede enviar el email.');
    return false;
  }
  console.log(`[sendNotificationTool] Intentando enviar email a ${input.passengerEmail} con asunto: "${input.subject}"`);
  try {
    // IMPORTANTE: Para producción, usa un email verificado en tu cuenta de Resend como 'from'.
    // 'onboarding@resend.dev' es para pruebas y puede tener limitaciones.
    const { data, error } = await resend.emails.send({
      from: `${APP_NAME} <onboarding@resend.dev>`, // Reemplaza con tu email verificado para producción
      to: [input.passengerEmail],
      subject: input.subject,
      html: `<p>${input.message.replace(/\n/g, '<br>')}</p>`, // Convertir saltos de línea a <br> para HTML
      text: input.message, // Versión en texto plano
    });

    if (error) {
      console.error('[sendNotificationTool] Error al enviar email con Resend:', JSON.stringify(error, null, 2));
      return false;
    }
    console.log('[sendNotificationTool] Email enviado exitosamente. ID:', data?.id);
    return true;
  } catch (e: any) {
    console.error('[sendNotificationTool] Excepción al enviar email:', JSON.stringify(e, null, 2));
    return false;
  }
});


export async function watchRoute(input: WatchRouteInput): Promise<WatchRouteOutput> {
  return watchRouteFlow(input);
}

const WatchRoutePromptInputSchema = WatchRouteInputSchema.extend({
    matchingTripsJson: z.string().describe('Un string JSON que representa un array de objetos PublishedTripDetails. Cada objeto describe un viaje publicado que coincide con el origen, destino y fecha. Si no se encontraron viajes, será un string JSON de un array vacío "[]".')
});

const prompt = ai.definePrompt({
  name: 'watchRoutePrompt',
  input: {schema: WatchRoutePromptInputSchema},
  output: {schema: WatchRouteOutputSchema},
  tools: [sendNotificationTool], 
  prompt: `Eres un vigilante de rutas inteligente para la aplicación ${APP_NAME}. Tu tarea es analizar una lista de viajes (proporcionada como un string JSON en 'matchingTripsJson') que ya han sido buscados y coinciden con el origen, destino y fecha de la ruta guardada de un pasajero.

  Información de la ruta guardada por el pasajero:
  - Correo del Pasajero: {{{passengerEmail}}}
  - Origen Preferido: {{{origin}}}
  - Destino Preferido: {{{destination}}}
  - Fecha Preferida: {{{date}}} (Formato YYYY-MM-DD)

  Viajes Encontrados (string JSON con detalles de viajes publicados):
  {{{matchingTripsJson}}}

  Proceso de Decisión OBLIGATORIO:
  1. Analiza el string JSON en 'matchingTripsJson'.
     a. Si el string representa un array vacío (ej: "[]"), significa que NO se encontraron viajes publicados que coincidan. En este caso:
        i. Establece 'routeMatchFound' en false.
        ii. Establece 'notificationSent' en false.
        iii. En el campo 'message' del output, indica claramente que no se encontraron viajes publicados para la ruta (Origen: {{{origin}}}, Destino: {{{destination}}}, Fecha: {{{date}}}). Por ejemplo: "No se encontraron viajes publicados para tu ruta de {{{origin}}} a {{{destination}}} en la fecha {{{date}}}. Seguiremos vigilando."

  2. Si 'matchingTripsJson' representa un array con UNO O MÁS viajes publicados:
     a. Selecciona el PRIMER viaje del array como la coincidencia principal.
     b. Construye un mensaje de notificación claro y amigable para el pasajero. El mensaje DEBE incluir:
        - Nombre de la aplicación: ${APP_NAME}.
        - Origen del viaje encontrado.
        - Destino del viaje encontrado.
        - Fecha y Hora de salida del viaje encontrado (el campo 'departureDateTime' del viaje encontrado YA ESTÁ FORMATEADO como "dd MMM yyyy a las HH:mm").
        - Nombre del conductor (campo 'driverFullName'), si está disponible, o "Conductor Anónimo".
        - Correo electrónico del conductor (campo 'driverEmail'), si está disponible.
        - Número de asientos disponibles (campo 'seatsAvailable').
        - Un saludo cordial y una despedida.
     c. Define un ASUNTO para el correo. Debe ser informativo, por ejemplo: "¡Buenas noticias! Encontramos un viaje para ti en ${APP_NAME}".
     d. Usa la herramienta 'sendNotificationTool' para enviar este mensaje y asunto al 'passengerEmail' ({{{passengerEmail}}}) del input.
     e. Establece 'routeMatchFound' en true.
     f. Establece 'notificationSent' según el resultado de la herramienta 'sendNotificationTool'.
     g. En el campo 'message' del output, resume la acción (ej: "¡Coincidencia encontrada! Se encontró un viaje de {{{origin}}} a {{{destination}}} para el {{{date}}} y se ha notificado al pasajero."). Si la notificación falló pero el viaje se encontró, indícalo (ej: "Se encontró un viaje, pero la notificación al pasajero falló.").

  No inventes viajes. Basa tu decisión EXCLUSIVAMENTE en los datos de 'matchingTripsJson'.
  Asegúrate de que la salida sea un objeto JSON válido que cumpla con WatchRouteOutputSchema.
`,
  config: {
    safetySettings: [
      { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_ONLY_HIGH' },
      { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' },
      { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_MEDIUM_AND_ABOVE' },
      { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_LOW_AND_ABOVE' },
    ],
  },
});

const watchRouteFlow = ai.defineFlow(
  {
    name: 'watchRouteFlow',
    inputSchema: WatchRouteInputSchema,
    outputSchema: WatchRouteOutputSchema,
  },
  async (input) => {
    console.log('[watchRouteFlow] Flow iniciado con input:', JSON.stringify(input, null, 2));

    const searchInput: FindPublishedMatchingTripsInput = {
        origin: input.origin,
        destination: input.destination,
        searchDate: input.date,
    };
    console.log('[watchRouteFlow] Llamando a findPublishedMatchingTripsAction con input:', JSON.stringify(searchInput, null, 2));
    let matchingTrips: PublishedTripDetails[] = [];
    try {
        matchingTrips = await findPublishedMatchingTripsAction(searchInput);
        console.log(`[watchRouteFlow] findPublishedMatchingTripsAction devolvió ${matchingTrips.length} viaje(s). Datos (primeros 500 chars):`, JSON.stringify(matchingTrips, null, 2).substring(0, 500));
    } catch (error: any) {
        console.error('[watchRouteFlow] Error al llamar a findPublishedMatchingTripsAction:', error.message ? error.message : JSON.stringify(error));
    }
    
    const matchingTripsJson = JSON.stringify(matchingTrips);
    console.log('[watchRouteFlow] String JSON de viajes coincidentes para el LLM:', matchingTripsJson);

    const promptInput = {
        ...input,
        matchingTripsJson: matchingTripsJson,
    };

    console.log('[watchRouteFlow] Input para el prompt del LLM (incluyendo matchingTripsJson):', JSON.stringify(promptInput, null, 2));
    const {output} = await prompt(promptInput); 

    console.log('[watchRouteFlow] Output del prompt (LLM):', JSON.stringify(output, null, 2));

    if (output) {
      if (output.routeMatchFound && !output.notificationSent) {
        console.warn("[watchRouteFlow] LLM reportó routeMatchFound=true pero notificationSent=false. Esto podría indicar un problema en la herramienta de notificación o en la lógica del LLM para usarla.");
      }
      return output;
    } else {
      console.error('[watchRouteFlow] No se recibió una respuesta estructurada del LLM.');
      return {
        routeMatchFound: false,
        notificationSent: false,
        message: `Error: No se recibió una respuesta estructurada del LLM para la ruta de ${input.origin} a ${input.destination}.`,
      };
    }
  }
);
