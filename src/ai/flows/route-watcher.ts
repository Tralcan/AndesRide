// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview A route watching AI agent that notifies users when rides match their saved routes.
 *
 * - watchRoute - A function that handles the route watching process.
 * - WatchRouteInput - The input type for the watchRoute function.
 * - WatchRouteOutput - The return type for the watchRoute function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const WatchRouteInputSchema = z.object({
  passengerEmail: z.string().email().describe('The email address of the passenger.'),
  origin: z.string().describe('The desired origin location for the route.'),
  destination: z.string().describe('The desired destination location for the route.'),
  date: z.string().describe('The desired date for the route (YYYY-MM-DD).'),
  driverEmail: z.string().email().optional().describe('The email address of the driver offering the ride, if available.'),
});
export type WatchRouteInput = z.infer<typeof WatchRouteInputSchema>;

const WatchRouteOutputSchema = z.object({
  routeMatchFound: z.boolean().describe('Whether a matching route was found.'),
  notificationSent: z.boolean().describe('Whether a notification was sent to the passenger.'),
  message: z.string().describe('A message indicating the result of the route watch.'),
});
export type WatchRouteOutput = z.infer<typeof WatchRouteOutputSchema>;


// Define a tool to send email notifications (implementation not provided)
const sendNotification = ai.defineTool({
  name: 'sendNotification',
  description: 'Sends an email notification to the passenger about a matching ride.',
  inputSchema: z.object({
    passengerEmail: z.string().email().describe('The email address of the passenger.'),
    message: z.string().describe('The message to send in the notification.'),
  }),
  outputSchema: z.boolean().describe('Whether the notification was sent successfully.'),
},
async (input) => {
  // Placeholder implementation for sending a notification.
  // In a real application, this would use an email service or similar.
  console.log(`Sending notification to ${input.passengerEmail}: ${input.message}`);
  return true; // Assume success for this example
});


export async function watchRoute(input: WatchRouteInput): Promise<WatchRouteOutput> {
  return watchRouteFlow(input);
}

const prompt = ai.definePrompt({
  name: 'watchRoutePrompt',
  input: {schema: WatchRouteInputSchema},
  output: {schema: WatchRouteOutputSchema},
  tools: [sendNotification],
  prompt: `You are a route watcher that identifies when a ride matches a passenger's preferred route and sends a notification.

  Passenger Email: {{{passengerEmail}}}
  Origin: {{{origin}}}
  Destination: {{{destination}}}
  Date: {{{date}}}

  Driver Email (if available): {{{driverEmail}}}

  Determine if a ride matches the passenger's preferred route. If it matches, use the sendNotification tool to notify the passenger.
  The notification message should include the driver's email (if available), origin, destination and date.
  Set routeMatchFound to true if a match is found, otherwise false.
  Set notificationSent to true if a notification is sent, otherwise false.
  Include a helpful message in the message field to summarize the results.

  If no driver email is available, mention that the notification includes information about the origin, destination and date.

  Ensure that the output is a valid JSON object.
`,
  config: {
    safetySettings: [
      {
        category: 'HARM_CATEGORY_HATE_SPEECH',
        threshold: 'BLOCK_ONLY_HIGH',
      },
      {
        category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
        threshold: 'BLOCK_NONE',
      },
      {
        category: 'HARM_CATEGORY_HARASSMENT',
        threshold: 'BLOCK_MEDIUM_AND_ABOVE',
      },
      {
        category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
        threshold: 'BLOCK_LOW_AND_ABOVE',
      },
    ],
  },
});

const watchRouteFlow = ai.defineFlow(
  {
    name: 'watchRouteFlow',
    inputSchema: WatchRouteInputSchema,
    outputSchema: WatchRouteOutputSchema,
  },
  async input => {
    const {output} = await prompt(input);

    if (output) {
      return output;
    } else {
      return {
        routeMatchFound: false,
        notificationSent: false,
        message: 'No output received from the prompt.',
      };
    }
  }
);
